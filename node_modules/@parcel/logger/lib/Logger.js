"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patchConsole = patchConsole;
exports.default = void 0;

var _events = require("@parcel/events");

var _util = require("util");

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to get private field on non-instance"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

class Logger {
  constructor() {
    _logEmitter.set(this, {
      writable: true,
      value: new _events.ValueEmitter()
    });
  }

  onLog(cb) {
    return _classPrivateFieldGet(this, _logEmitter).addListener(cb);
  }

  verbose(message) {
    _classPrivateFieldGet(this, _logEmitter).emit({
      type: 'log',
      level: 'verbose',
      message
    });
  }

  info(message) {
    this.log(message);
  }

  log(message) {
    _classPrivateFieldGet(this, _logEmitter).emit({
      type: 'log',
      level: 'info',
      message
    });
  }

  warn(err) {
    _classPrivateFieldGet(this, _logEmitter).emit({
      type: 'log',
      level: 'warn',
      message: err
    });
  }

  error(err) {
    _classPrivateFieldGet(this, _logEmitter).emit({
      type: 'log',
      level: 'error',
      message: err
    });
  }

  progress(message) {
    _classPrivateFieldGet(this, _logEmitter).emit({
      type: 'log',
      level: 'progress',
      message
    });
  }

}

var _logEmitter = new WeakMap();

const logger = new Logger();
var _default = logger;
exports.default = _default;
let consolePatched = false; // Patch `console` APIs within workers to forward their messages to the Logger
// at the appropriate levels.
// TODO: Implement the rest of the console api as needed.
// TODO: Does this need to be disposable/reversible?

function patchConsole() {
  if (consolePatched) {
    return;
  }
  /* eslint-disable no-console */
  // $FlowFixMe


  console.log = console.info = (...messages) => {
    logger.info(joinLogMessages(messages));
  }; // $FlowFixMe


  console.debug = (...messages) => {
    // TODO: dedicated debug level?
    logger.verbose(joinLogMessages(messages));
  }; // $FlowFixMe


  console.warn = (...messages) => {
    logger.warn(joinLogMessages(messages));
  }; // $FlowFixMe


  console.error = (...messages) => {
    logger.error(joinLogMessages(messages));
  };
  /* eslint-enable no-console */


  consolePatched = true;
}

function joinLogMessages(messages) {
  return messages.map(m => typeof m === 'string' ? m : (0, _util.inspect)(m)).join(' ');
}